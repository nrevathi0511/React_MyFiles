tionBaseObject(options, getOptionsNameMap(), pathOptions);
}
function serializeWatchOptions(options) {
  return serializeOptionBaseObject(options, getWatchOptionsNameMap());
}
function serializeOptionBaseObject(options, { optionsNameMap }, pathOptions) {
  const result = /* @__PURE__ */ new Map();
  const getCanonicalFileName = pathOptions && createGetCanonicalFileName(pathOptions.useCaseSensitiveFileNames);
  for (const name in options) {
    if (hasProperty(options, name)) {
      if (optionsNameMap.has(name) && (optionsNameMap.get(name).category === Diagnostics.Command_line_Options || optionsNameMap.get(name).category === Diagnostics.Output_Formatting)) {
        continue;
      }
      const value = options[name];
      const optionDefinition = optionsNameMap.get(name.toLowerCase());
      if (optionDefinition) {
        Debug.assert(optionDefinition.type !== "listOrElement");
        const customTypeMap = getCustomTypeMapOfCommandLineOption(optionDefinition);
        if (!customTypeMap) {
          if (pathOptions && optionDefinition.isFilePath) {
            result.set(name, getRelativePathFromFile(pathOptions.configFilePath, getNormalizedAbsolutePath(value, getDirectoryPath(pathOptions.configFilePath)), getCanonicalFileName));
          } else {
            result.set(name, value);
          }
        } else {
          if (optionDefinition.type === "list") {
            result.set(name, value.map((element) => getNameOfCompilerOptionValue(element, customTypeMap)));
          } else {
            result.set(name, getNameOfCompilerOptionValue(value, customTypeMap));
          }
        }
      }
    }
  }
  return result;
}
function getCompilerOptionsDiffValue(options, newLine) {
  const compilerOptionsMap = getSerializedCompilerOption(options);
  return getOverwrittenDefaultOptions();
  function makePadding(paddingLength) {
    return Array(paddingLength + 1).join(" ");
  }
  function getOverwrittenDefaultOptions() {
    const result = [];
    const tab = makePadding(2);
    commandOptionsWithoutBuild.forEach((cmd) => {
      if (!compilerOptionsMap.has(cmd.name)) {
        return;
      }
      const newValue = compilerOptionsMap.get(cmd.name);
      const defaultValue = getDefaultValueForOption(cmd);
      if (newValue !== defaultValue) {
        result.push(`${tab}${cmd.name}: ${newValue}`);
      } else if (hasProperty(defaultInitCompilerOptions, cmd.name)) {
        result.push(`${tab}${cmd.name}: ${defaultValue}`);
      }
    });
    return result.join(newLine) + newLine;
  }
}
function getSerializedCompilerOption(options) {
  const compilerOptions = extend(options, defaultInitCompilerOptions);
  return serializeCompilerOptions(compilerOptions);
}
function generateTSConfig(options, fileNames, newLine) {
  const compilerOptionsMap = getSerializedCompilerOption(options);
  return writeConfigurations();
  function makePadding(paddingLength) {
    return Array(paddingLength + 1).join(" ");
  }
  function isAllowedOptionForOutput({ category, name, isCommandLineOnly }) {
    const categoriesToSkip = [Diagnostics.Command_line_Options, Diagnostics.Editor_Support, Diagnostics.Compiler_Diagnostics, Diagnostics.Backwards_Compatibility, Diagnostics.Watch_and_Build_Modes, Diagnostics.Output_Formatting];
    return !isCommandLineOnly && category !== void 0 && (!categoriesToSkip.includes(category) || compilerOptionsMap.has(name));
  }
  function writeConfigurations() {
    const categorizedOptions = /* @__PURE__ */ new Map();
    categorizedOptions.set(Diagnostics.Projects, []);
    categorizedOptions.set(Diagnostics.Language_and_Environment, []);
    categorizedOptions.set(Diagnostics.Modules, []);
    categorizedOptions.set(Diagnostics.JavaScript_Support, []);
    categorizedOptions.set(Diagnostics.Emit, []);
    categorizedOptions.set(Diagnostics.Interop_Constraints, []);
    categorizedOptions.set(Diagnostics.Type_Checking, []);
    categorizedOptions.set(Diagnostics.Completeness, []);
    for (const option of optionDeclarations) {
      if (isAllowedOptionForOutput(option)) {
        let listForCategory = categorizedOptions.get(option.category);
        if (!listForCategory)
          categorizedOptions.set(option.category, listForCategory = []);
        listForCategory.push(option);
      }
    }
    let marginLength = 0;
    let seenKnownKeys = 0;
    const entries = [];
    categorizedOptions.forEach((options2, category) => {
      if (entries.length !== 0) {
        entries.push({ value: "" });
      }
      entries.push({ value: `/* ${getLocaleSpecificMessage(category)} */` });
      for (const option of options2) {
       