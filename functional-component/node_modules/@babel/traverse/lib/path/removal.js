)) {
        constantDescription = formatStringFromArgs(getLocaleSpecificMessage(Diagnostics.Extract_to_0_in_enclosing_scope), [constantDescriptionPart]);
      }
      return {
        functionExtraction: {
          description: functionDescription,
          errors: functionErrorsPerScope[i]
        },
        constantExtraction: {
          description: constantDescription,
          errors: constantErrorsPerScope[i]
        }
      };
    });
    return extractions;
  }
  function getPossibleExtractionsWorker(targetRange, context) {
    const { file: sourceFile } = context;
    const scopes = collectEnclosingScopes(targetRange);
    const enclosingTextRange = getEnclosingTextRange(targetRange, sourceFile);
    const readsAndWrites = collectReadsAndWrites(
      targetRange,
      scopes,
      enclosingTextRange,
      sourceFile,
      context.program.getTypeChecker(),
      context.cancellationToken
    );
    return { scopes, readsAndWrites };
  }
  function getDescriptionForFunctionInScope(scope) {
    return isFunctionLikeDeclaration(scope) ? "inner function" : isClassLike(scope) ? "method" : "function";
  }
  function getDescriptionForConstantInScope(scope) {
    return isClassLike(scope) ? "readonly field" : "constant";
  }
  function getDescriptionForFunctionLikeDeclaration(scope) {
    switch (scope.kind) {
      case 173 /* Constructor */:
        return "constructor";
      case 215 /* FunctionExpression */:
      case 259 /* FunctionDeclaration */:
        return scope.name ? `function '${scope.name.text}'` : ANONYMOUS;
      case 216 /* Arr