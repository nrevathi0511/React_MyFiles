isIdentifierTypePredicate(predicate) {
  return predicate && predicate.kind === 1 /* Identifier */;
}
function isThisTypePredicate(predicate) {
  return predicate && predicate.kind === 0 /* This */;
}
function getPropertyAssignment(objectLiteral, key, key2) {
  return objectLiteral.properties.filter((property) => {
    if (property.kind === 299 /* PropertyAssignment */) {
      const propName = tryGetTextOfPropertyName(property.name);
      return key === propName || !!key2 && key2 === propName;
    }
    return false;
  });
}
function getPropertyArrayElementValue(objectLiteral, propKey, elementValue) {
  return firstDefined(getPropertyAssignment(objectLiteral, propKey), (property) => isArrayLiteralExpression(property.initializer) ? find(property.initializer.elements, (element) => isStringLiteral(element) && element.text === elementValue) : void 0);
}
function getTsConfigObjectLiteralExpression(tsConfigSourceFile) {
  if (tsConfigSourceFile && tsConfigSourceFile.statements.length) {
    const expression = tsConfigSourceFile.statements[0].expression;
    return tryCast(expression, isObjectLiteralExpression);
  }
}
function getTsConfigPropArrayElementValue(tsConfigSourceFile, propKey, elementValue) {
  return firstDefined(getTsConfigPropArray(tsConfigSourceFile, propKey), (property) => isArrayLiteralExpression(property.initializer) ? find(property.initializer.elements, (element) => isStringLiteral(element) && element.text === elementValue) : void 0);
}
function getTsConfigPropArray(tsConfigSourceFile, propKey) {
  const jsonObjectLiteral = getTsConfigObjectLiteralExpression(tsConfigSourceFile);
  return jsonObjectLiteral ? getPropertyAssignment(jsonObjectLiteral, propKey) : emptyArray;
}
function getContainingFunction(node) {
  return findAncestor(node.parent, isFunctionLike);
}
function getContainingFunctionDeclaration(node) {
  return findAncestor(node.parent, isFunctionLikeDeclaration);
}
function getContainingClass(node) {
  return findAncestor(node.parent, isClassLike);
}
function getContainingClassStaticBlock(node) {
  return findAncestor(node.parent, (n) => {
    if (isClassLike(n) || isFunctionLike(n)) {
      return "quit";
    }
    return isClassStaticBlockDeclaration(n);
  });
}
function getContainingFunctionOrClassStaticBlock(node) {
  return findAncestor(node.parent, isFunctionLikeOrClassStaticBlockDeclaration);
}
function getThisContainer(node, includeArrowFunctions, includeClassComputedPropertyName) {
  Debug.assert(node.kind !== 308 /* SourceFile */);
  while (true) {
    node = node.parent;
    if (!node) {
      return Debug.fail();
    }
    switch (node.kind) {
      case 164 /* ComputedPropertyName */:
        if (includeClassComputedPropertyName && isClassLike(node.parent.parent)) {
          return node;
        }
        node = node.parent.parent;
        break;
      case 167 /* Decorator */:
        if (node.parent.kind === 166 /* Parameter */ && isClassElement(node.parent.parent)) {
          node = node.parent.parent;
        } else if (isClassElement(node.parent)) {
          node = node.parent;
        }
        break;
      case 216 /* ArrowFunction */:
        if (!includeArrowFunctions) {
          continue;
        }
      case 259 /* FunctionDeclaration */:
      case 215 /* FunctionExpression */:
      case 264 /* ModuleDeclaration */:
      case 172 /* ClassStaticBlockDeclaration */:
      case 169 /* PropertyDeclaration */:
      case 168 /* PropertySignature */:
      case 171 /* MethodDeclaration */:
      case 170 /* MethodSignature */:
      case 173 /* Constructor */:
      case 174 /* GetAccessor */:
      case 175 /* SetAccessor */:
      case 176 /* CallSignature */:
      case 177 /* ConstructSignature */:
      case 178 /* IndexSignature */:
      case 263 /* EnumDeclaration */:
      case 308 /* SourceFile */:
        return node;
    }
  }
}
function isThisContainerOrFunctionBlock(node) {
  switch (node.kind) {
    case 216 /* ArrowFunction */:
    case 259 /* FunctionDeclaration */:
    case 215 /* FunctionExpression */:
    case 169 /* PropertyDeclaration */:
      return true;
    case 238 /* Block */:
      switch (node.parent.kind) {
        case 173 /* Constructor */:
        case 171 /* MethodDeclaration */:
        case 174 /* GetAccessor */:
        case 175 /* SetAccessor */:
          return true;
        default:
          return false;
      }
    default:
      return false;
  }
}
function isInTopLevelContext(node) {
  if (isIdentifier(node) && (isClassDeclaration(node.parent) || isFunctionDeclaration(node.parent)) && node.parent.name === node) {
    node = node.parent;
  }
  const container = getThisContainer(
    node,
    /*includeArrowFunctions*/
    true,
    /*includeClassComputedPropertyName*/
    false
  );
  return isSourceFile(container);
}
function getNewTargetContainer(node) {
  const container = getThisContainer(
    node,
    /*includeArrowFunctions*/
    false,
    /*includeClassComputedPropertyName*/
    false
  );
  if (container) {
    switch (container.kind) {
      case 173 /* Constructor */:
      case 259 /* FunctionDeclaration */:
      case 215 /* FunctionExpression */:
        return container;
    }
  }
  return void 0;
}
function getSuperContainer(node, stopOnFunctions) {
  while (true) {
    node = node.parent;
    if (!node) {
      return void 0;
    }
    switch (node.kind) {
      case 164 /* ComputedPropertyName */:
        node = node.parent;
        break;
      case 259 /* FunctionDeclaration */:
      case 215 /* FunctionExpression */:
      case 216 /* ArrowFunction */:
        if (!stopOnFunctions) {
          continue;
        }
      case 169 /* PropertyDeclaration */:
      case 168 /* PropertySignature */:
      case 171 /* MethodDeclaration */:
      case 170 /* MethodSignature */:
      case 173 /* Constructor */:
      case 174 /* GetAccessor */:
      case 175 /* SetAccessor */:
      case 172 /* ClassStaticBlockDeclaration */:
        return node;
      case 167 /* Decorator */:
        if (node.parent.kind === 166 /* Parameter */ && isClassElement(node.parent.parent)) {
          node = node.parent.parent;
        } else if (isClassElement(node.parent)) {
          node = node.parent;
        }
        break;
    }
  }
}
function getImmediatelyInvokedFunctionExpression(func) {
  if (func.kind === 215 /* FunctionExpression */ || func.kind === 216 /* ArrowFunction */) {
    let prev = func;
    let parent2 = func.parent;
    while (parent2.kind === 214 /* ParenthesizedExpression */) {
      prev = parent2;
      parent2 = parent2.parent;
    }
    if (parent2.kind === 210 /* CallExpression */ && parent2.expression === prev) {
      return parent2;
    }
  }
}
function isSuperOrSuperProperty(node) {
  return node.kind === 106 /* SuperKeyword */ || isSuperProperty(node);
}
function isSuperProperty(node) {
  const kind = node.kind;
  return (kind === 208 /* PropertyAccessExpression */ || kind === 209 /* ElementAccessExpression */) && node.expression.kind === 106 /* SuperKeyword */;
}
function isThisProperty(node) {
  const kind = node.kind;
  return (kind === 208 /* PropertyAccessExpression */ || kind === 209 /* ElementAccessExpression */) && node.expression.kind === 108 /* ThisKeyword */;
}
function isThisInitializedDeclaration(node) {
  var _a2;
  return !!node && isVariableDeclaration(node) && ((_a2 = node.initializer) == null ? void 0 : _a2.kind) === 108 /* ThisKeyword */;
}
function isThisInitializedObjectBindingExpression(node) {
  return !!node && (isShorthandPropertyAssignment(node) || isPropertyAssignment(node)) && isBinaryExpression(node.parent.parent) && node.parent.parent.operatorToken.kind === 63 /* EqualsToken */ && node.parent.parent.right.kind === 108 /* ThisKeyword */;
}
function getEntityNameFromTypeNode(node) {
  switch (node.kind) {
    case 180 /* TypeReference */:
      return node.typeName;
    case 230 /* ExpressionWithTypeArguments */:
      return isEntityNameExpression(node.expression) ? node.expression : void 0;
    case 79 /* Identifier */:
    case 163 /* QualifiedName */:
      return node;
  }
  return void 0;
}
function getInvokedExpression(node) {
  switch (node.kind) {
    case 212 /* TaggedTemplateExpression */:
      return node.tag;
    case 283 /* JsxOpeningElement */:
    case 282 /* JsxSelfClosingElement */:
      return node.tagName;
    default:
      return node.expression;
  }
}
function nodeCanBeDecorated(useLegacyDecorators, node, parent2, grandparent) {
  if (useLegacyDecorators && isNamedDeclaration(node) && isPrivateIdentifier(node.name)) {
    return false;
  }
  switch (node.kind) {
    case 260 /* ClassDeclaration */:
      return true;
    case 228 /* ClassExpression */:
      return !useLegacyDecorators;
    case 169 /* PropertyDeclaration */:
      return parent2 !== void 0 && (useLegacyDecorators ? isClassDeclaration(parent2) : isClassLike(parent2) && !hasAbstractModifier(node) && !hasAmbientModifier(node));
    case 174 /* GetAccessor */:
    case 175 /* SetAccessor */:
    case 171 /* MethodDeclaration */:
      return node.body !== void 0 && parent2 !== void 0 && (useLegacyDecorators ? isClassDeclaration(parent2) : isClassLike(parent2));
    case 166 /* Parameter */:
      if (!useLegacyDecorators)
        return false;
      return parent2 !== void 0 && parent2.body !== void 0 && (parent2.kind === 173 /* Constructor */ || parent2.kind === 171 /* MethodDeclaration */ || parent2.kind === 175 /* SetAccessor */) && getThisParameter(parent2) !== node && grandparent !== void 0 && grandparent.kind === 260 /* ClassDeclaration */;
  }
  return false;
}
function nodeIsDecorated(useLegacyDecorators, node, parent2, grandparent) {
  return hasDecorators(node) && nodeCanBeDecorated(useLegacyDecorators, node, parent2, grandparent);
}
function nodeOrChildIsDecorated(useLegacyDecorators, node, parent2, grandparent) {
  return nodeIsDecorated(useLegacyDecorators, node, parent2, grandparent) || childIsDecorated(useLegacyDecorators, node, parent2);
}
function childIsDecorated(useLegacyDecorators, node, parent2) {
  switch (node.kind) {
    case 260 /* ClassDeclaration */:
      return some(node.members, (m) => nodeOrChildIsDecorated(useLegacyDecorators, m, node, parent2));
    case 228 /* ClassExpression */:
      return !useLegacyDecorators && some(node.members, (m) => nodeOrChildIsDecorated(useLegacyDecorators, m, node, parent2));
    case 171 /* MethodDeclaration */:
    case 175 /* SetAccessor */:
    case 173 /* Constructor */:
      return some(node.parameters, (p) => nodeIsDecorated(useLegacyDecorators, p, node, parent2));
    default:
      return false;
  }
}
function classOrConstructorParameterIsDecorated(useLegacyDecorators, node) {
  if (nodeIsDecorated(useLegacyDecorators, node))
    return true;
  const constructor = getFirstConstructorWithBody(node);
  return !!constructor && childIsDecorated(useLegacyDecorators, constructor, node);
}
function classElementOrClassElementParameterIsDecorated(useLegacyDecorators, node, parent2) {
  let parameters;
  if (isAccessor(node)) {
    const { firstAccessor, secondAccessor, setAccessor } = getAllAccessorDeclarations(parent2.members, node);
    const firstAccessorWithDecorators = hasDecorators(firstAccessor) ? firstAccessor : secondAccessor && hasDecorators(secondAccessor) ? secondAccessor : void 0;
    if (!firstAccessorWithDecorators || node !== firstAccessorWithDecorators) {
      return false;
    }
    parameters = setAccessor == null ? void 0 : setAccessor.parameters;
  } else if (isMethodDeclaration(node)) {
    parameters = node.parameters;
  }
  if (nodeIsDecorated(useLegacyDecorators, node, parent2)) {
    return true;
  }
  if (parameters) {
    for (const parameter of parameters) {
      if (parameterIsThisKeyword(parameter))
        continue;
      if (nodeIsDecorated(useLegacyDecorators, parameter, node, parent2))
        return true;
    }
  }
  return false;
}
function isEmptyStringLiteral(node) {
  if (node.textSourceNode) {
    switch (node.textSourceNode.kind) {
      case 10 /* StringLiteral */:
        return isEmptyStringLiteral(node.textSourceNode);
      case 14 /* NoSubstitutionTemplateLiteral */:
        return node.text === "";
    }
    return false;
  }
  return node.text === "";
}
function isJSXTagName(node) {
  const { parent: parent2 } = node;
  if (parent2.kind === 283 /* JsxOpeningElement */ || parent2.kind === 282 /* JsxSelfClosingElement */ || parent2.kind === 284 /* JsxClosingElement */) {
    return parent2.tagName === node;
  }
  return false;
}
function isExpressionNode(node) {
  switch (node.kind) {
    case 106 /* SuperKeyword */:
    case 104 /* NullKeyword */:
    case 110 /* TrueKeyword */:
    case 95 /* FalseKeyword */:
    case 13 /* RegularExpressionLiteral */:
    case 206 /* ArrayLiteralExpression */:
    case 207 /* ObjectLiteralExpression */:
    case 208 /* PropertyAccessExpression */:
    case 209 /* ElementAccessExpression */:
    case 210 /* CallExpression */:
    case 211 /* NewExpression */:
    case 212 /* TaggedTemplateExpression */:
    case 231 /* AsExpression */:
    case 213 /* TypeAssertionExpression */:
    case 235 /* SatisfiesExpression */:
    case 232 /* NonNullExpression */:
    case 214 /* ParenthesizedExpression */:
    case 215 /* FunctionExpression */:
    case 228 /* ClassExpression */:
    case 216 /* ArrowFunction */:
    case 219 /* VoidExpression */:
    case 217 /* DeleteExpression */:
    case 218 /* TypeOfExpression */:
    case 221 /* PrefixUnaryExpression */:
    case 222 /* PostfixUnaryExpression */:
    case 223 /* BinaryExpression */:
    case 224 /* ConditionalExpression */:
    case 227 /* SpreadElement */:
    case 225 /* TemplateExpression */:
    case 229 /* OmittedExpression */:
    case 281 /* JsxElement */:
    case 282 /* JsxSelfClosingElement */:
    case 285 /* JsxFragment */:
    case 226 /* YieldExpression */:
    case 220 /* AwaitExpression */:
    case 233 /* MetaProperty */:
      return true;
    case 230 /* ExpressionWithTypeArguments */:
      return !isHeritageClause(node.parent) && !isJSDocAugmentsTag(node.parent);
    case 163 /* QualifiedName */:
      while (node.parent.kind === 163 /* QualifiedName */) {
        node = node.parent;
      }
      return node.parent.kind === 183 /* TypeQuery */ || isJSDocLinkLike(node.parent) || isJSDocNameReference(node.parent) || isJSDocMemberName(node.parent) || isJSXTagName(node);
    case 314 /* JSDocMemberName */:
      while (isJSDocMemberName(node.parent)) {
        node = node.parent;
      }
      return node.parent.kind === 183 /* TypeQuery */ || isJSDocLinkLike(node.parent) || isJSDocNameReference(node.parent) || isJSDocMemberName(node.parent) || isJSXTagName(node);
    case 80 /* PrivateIdentifier */:
      return isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === 101 /* InKeyword */;
    case 79 /* Identifier */:
      if (node.parent.kind === 183 /* TypeQuery */ || isJSDocLinkLike(node.parent) || isJSDocNameReference(node.parent) || isJSDocMemberName(node.parent) || isJSXTagName(node)) {
        return true;
      }
    case 8 /* NumericLiteral */:
    case 9 /* BigIntLiteral */:
    case 10 /* StringLiteral */:
    case 14 /* NoSubstitutionTemplateLiteral */:
    case 108 /* ThisKeyword */:
      return isInExpressionContext(node);
    default:
      return false;
  }
}
function isInExpressionContext(node) {
  const { parent: parent2 } = node;
  switch (parent2.kind) {
    case 257 /* VariableDeclaration */:
    case 166 /* Parameter */:
    case 169 /* PropertyDeclaration */:
    case 168 /* PropertySignature */:
    case 302 /* EnumMember */:
    case 299 /* PropertyAssignment */:
    case 205 /* BindingElement */:
      return parent2.initializer === node;
    case 241 /* ExpressionStatement */:
    case 242 /* IfStatement */:
    case 243 /* DoStatement */:
    case 244 /* WhileStatement */:
    case 250 /* ReturnStatement */:
    case 251 /* WithStatement */:
    case 252 /* SwitchStatement */:
    case 292 /* CaseClause */:
    case 254 /* ThrowStatement */:
      return parent2.exp